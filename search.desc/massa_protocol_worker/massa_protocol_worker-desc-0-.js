searchState.loadedDescShard("massa_protocol_worker", 0, "This function exists because consensus need the protocol …\nOptimized batch signature verifier\nstart a new <code>ProtocolController</code> from a <code>ProtocolConfig</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nSends the order to propagate the header of a block\nCalls <code>U::from(self)</code>.\nNotify to protocol an attack attempt.\npropagate endorsements to connected node\nPropagate a batch of operation ids (from pool).\nupdate the block wish list\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCopyright (c) 2023 MASSA LABS info@massa.net This file …\nCache on block knowledge by our node and its peers\ncache of blocks known by peers\ncache of previously checked headers\nReturns the argument unchanged.\nMark a given node’s knowledge of a list of blocks as …\nCalls <code>U::from(self)</code>.\nmax number of blocks known in peer knowledge cache\nA block, or it’s header, amounted to an attempted attack.\nCommands that the block handler can process\nNotify block integration of a given block.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nblock id\nblock storage\nWish list delta\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nadd to wish list\nremove from wish list\nRequest block data\nReply to a block data request\nMessage asking the peer for info on a list of blocks.\nMessage replying with info on a list of blocks.\nAsk header\nHeader\nBlock header\nBlock not found\nAsk for the list of operation IDs of the block\nList of operation IDs within the block\nAsk for a subset of operations of the block\nRequested full operations of the block\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nID of the block to ask info for.\nID of the block to reply info for.\nBlock info to ask for.\nBlock info reply.\nStorage holding the block and its dependencies during its …\nShared access to the list of peers connected to us\ntry to ban a list of peers\nSerializer for block-related messages\nShared access to the block cache\nProtocol config\nReturns the argument unchanged.\nReturns the argument unchanged.\nClone of the block header to avoid locking storage during …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChannel to send commands to the peer management system …\nPropagate blocks to peers that need them\nReceiver for commands\nBlocks stored for propagation\nTime when propagation was initiated\nInfo about a block we’ve seen\nsend a ban peer command to the peer handler\nCheck if the incoming header network version is compatible …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalled when we have fully gathered a block\nReturn the sum of all operation’s serialized sizes in …\nThe header of the block.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMark a block as invalid\nPerforms validity checks on a block header, and if valid …\nA remote node asked the local node for block data\nWe received the full operations of a block.\nOn block header received from a node.\nA peer sent us a response to one of our requests for block …\nWe received a list of operations for a block.\nOperations ids. None if not received yet\nRemove the given blocks from the local wishlist\nOperations and endorsements contained in the block, if we…\nfunction that updates the global state of block retrieval\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCache of endorsements\nList of endorsements we checked recently\nList of endorsements known by peers\nReturns the argument unchanged.\nMark an endorsement ID as checked by us\nMark a list of endorsement IDs prefixes as known by a peer\nCalls <code>U::from(self)</code>.\nMaximum number of endorsements known by a peer\nCreate a new EndorsementCache\nUpdate caches to remove all data from disconnected peers\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEndorsements\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEndorsements need to propagate fast, so no buffering\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPerform propagation of endorsements to the connected peers\nsend a ban peer command to the peer handler\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nNote endorsements coming from a given node, and propagate …\nProcess incoming message\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCache for operations\nList of operations we checked recently\nList of operation ID prefixes we checked recently\nReturns the argument unchanged.\nMark an operation ID as checked by us\nMark a list of operation ID prefixes as known by a peer\nCalls <code>U::from(self)</code>.\nMaximum number of operations known by a peer\nCreate a new OperationCache\nList of operations known by peers\nUpdate caches to remove all data from disconnected peers\noperations ids\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSomeone ask for operations.\nLimits used in the deserialization of <code>OperationMessage</code>\nA list of operations\nBatch of operation ids\nChain id\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum size of a user datastore value\nMaximum size of a function name\nMaximum number of entries in the op datastore\nMaximum size of a op datastore key\nMaximum size of a op datastore value\nMaximum of full operations sent in one message\nMaximum number of prefix ids that can be asked to …\nMaximum size of parameters\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPrune the list of operations kept for propagation.\nStructure containing a Batch of <code>operation_ids</code> we would …\nsend a ban peer command to the peer handler\nReturns the argument unchanged.\nReturns the argument unchanged.\nlast updated at instant\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaybe move this to propagation Process the reception of a …\nOn receive a batch of operation ids <code>op_batch</code> from another …\noperation prefix ids\nnode id\nThis file contains the definition of the peer management …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHash\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nListeners\nserialized version\nSignature\nTimestamp\nLimits used in the deserialization of <code>OperationMessage</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum number of listeners per peer\nMaximum number of peers per announcement\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieve the peer with the oldest test date.\nSelect max 100 peers to send to another peer The selected …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\npeers currently tested\nTested addresses used to avoid testing the same address …\nhistory of try connection to peers\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new tester (spawn a thread)\nprotocol manager used to stop the protocol\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nStop the protocol module\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSerialize the message\nLimit for small batch optimization\nEfficiently verifies a batch of signatures in parallel. …\nThis function exists because consensus need the protocol …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nstart a new <code>ProtocolController</code> from a <code>ProtocolConfig</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")